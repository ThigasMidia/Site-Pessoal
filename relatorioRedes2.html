<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
	<link href="https://fonts.cdnfonts.com/css/among-us" rel="stylesheet">
    <title>Relatório Redes2</title>
    <link rel="icon"
          href="assets/icones/icone.gif">
</head>
<body>
    <center>
        <br><br>
        <div class="elTb" style="height: 1400px; width: 1500px; align-self: center;">
            <p class="tituloBlog" style="font-size: 80px; text-shadow: 1px 2px green;">Blockchain de MiniCoin, uma moeda fantasia</p><br>
            <p class="tituloBlog" style="font-size: 38px;">Sofia Barbosa Candiotto (GRR20232333), Thiago José Barzotto (GRR 20235687)</p><br><br><br>
            <p class="tituloBlog" style="text-align: left; margin-left: 30px;">1. Introdução</p><br>
            <p class="textoBlog" style="font-size: 20px; margin-left: 15px; margin-right: 15px;">Este é um trabalho desenvolvido para a disciplina de Redes de Computadores 2. O trabalho consiste na construção de uma criptomoeda fantasia: a MiniCoin. Como todas as criptomoedas, a MiniCoin se baseia na construção de uma BlockChain. A construção da BlockChain se baseia em apenas um servidor e um cliente. O cliente faz requisições diretamente ao servidor de apenas 2 operações: depósito e saque. A operação de saque pode ser impedida caso o saldo da conta corrente for menor que o valor a ser realizado o saque. A operação, se bem sucedida, é armazenada como bloco na BlockChain.</p>
            <p class="tituloBlog" style="text-align: left; margin-left: 30px;">2. Conexão Cliente-Servidor</p><br>
            <p class="tituloBlog" style="text-align: left; margin-left: 40px; font-size: 30px;">2.1. Cliente</p><br>
            <p class="textoBlog" style="font-size: 20px; margin-left: 45px; margin-right: 15px;">O cliente funciona de maneira simples. O programa recebe como parâmetro o nome do servidor e a porta desejada pra conexão. Com o nome do servidor, o cliente obtém o endereço ip do mesmo. Após isso, para cada operação de sque ou depósito realizada pelo cliente é aberto um novo socket. A requisição é então enviada e o cliente espera uma resposta do servidor (se a operação foi bem sucedida ou se algum erro ocorreu). Então, o socket é fechado e o cliente espera o usuário escolher uma nova requisição que criará um novo socket para aquela requisição.</p>
            <p class="tituloBlog" style="text-align: left; margin-left: 40px; font-size: 30px;">2.2. Servidor</p><br>
            <p class="textoBlog" style="font-size: 20px; margin-left: 45px; margin-right: 15px;">O servidor funciona de uma maneira diferente. O programa recebe como parâmetro a porta desejada para conexão. O servidor então obtém o próprio endereço IP e cria um socket para "escutar" a rede, <i>bindando</i> o socket no IP do servidor e o deixando em <i>listen</i>. O servidor então entra em seu loop de uso onde o segundo socket para "aceitar" aceita requisições na fila do outro. Após o servidor tratar a mensagem recebida, envia uma mensagem ao cliente pelo socket de "aceitar" e fecha esse socket, encerrando essa requisição.</p>
            <p class="tituloBlog" style="text-align: left; margin-left: 30px;">3. BlockChain</p><br>
            <p class="textoBlog" style="font-size: 20px; margin-left: 45px; margin-right: 15px;"></p>
            <p class="tituloBlog" style="text-align: left; margin-left: 30px;">4. Códigos-Fonte e Logs</p><br>
            <p class="textoBlog" style="font-size: 20px; margin-left: 45px; margin-right: 15px;"></p>
        </div>
        <br><br>
    </center>
</body>